# Table of Contents

* [分布式事务的来龙去脉](#分布式事务的来龙去脉)
* [两阶段提交](#两阶段提交)
* [三阶段提交](#三阶段提交)
* [TCC(try confirm cancle)](#tcctry-confirm-cancle)
* [消息队列+本地事件表(适应于并发量不高,对数据实时性要求不高)](#消息队列本地事件表适应于并发量不高对数据实时性要求不高)
* [可靠消息服务](#可靠消息服务)
* [阿里巴巴分布式事务框架:Seata (seata.io)](#阿里巴巴分布式事务框架seata-seataio)
* [](#)


                                  分布式事务(情理之中,意料之外,少儿不宜)

# 分布式事务的来龙去脉
1:单体服务->使用spring事务
2:微服务调用共同完成一个功能,跨进程,跨服务的事务,每个微服务都有自己的DB.
  使用数据库的ACID的事务能保证微服务的事务吗?

降低一次请求事故发生的概率,先试一下
  
# 两阶段提交
 有一个事务协调器,事务管理者.微服务会注册到事务管理者上面.
 请求过来时, 事务管理者进行监听,第一阶段,事务管理者分别向微服务发起预提交;第二阶段,根据返回的结果,分别进行提交或回滚。
 缺陷：资源占用大,超时一直等待,效率慢,不能100%保证事务.  (CAP理论,三者不可兼得,AP或CP)
 
# 三阶段提交
为了优化两阶段的资源占用大的弊端,产生了三阶段,引出了超时机制
1:询问能否提交can commit  不占用资源
2:pre commit,预提交,微服务没有收到事务协调器的pre commit,回滚
3:do commit .这一阶段,如果没有收到事务协调者发出的指令,默认提交
弊端:不能100%保证事务成功,数据不一致,人工补偿.一般是通过脚本扫描,在一定时间内补偿.

# TCC(try confirm cancle)   
应用场景:应用在一些不支持事务的中间件
try:先尝试所有的业务,数据落库
confirm:如果try没有问题,执行cinfirm,什么都不做或者执行一些方法
cancle:如果try有一个失败,cancle做一些delete操作,做一些与try相反的操作,逆sql
 try,confirm,cancle失败重试,重试都不好就人工介入,或者告警.

# 消息队列+本地事件表(适应于并发量不高,对数据实时性要求不高)
一个请求进入系统A,触发业务,插入事件表,记录业务类型,事件类型,业务id等.A执行完成后返回,A系统通过单体事务来保证
A系统有定时任务,去读取事件表信息,发送一个mq中,修改事件的状态为已发送,这些在一个事务中完成
B系统监听消息,再插入一个事件表,事件状态为已接受,给mq返回一个ack.这可以在一个事务中完成.
B系统有一个定时任务,读取事件表,处理业务,这个可以在一个事务中完成,处理完之后将消息事件表状态改为已完成.
优点:吞吐量高,弊端是调用链不易太长,数据并不能实时,最终一致性

# 可靠消息服务
是对消息队列+本地事务表的改进. 增加一个服务,专门来做这个事件表
一个请求过来到A服务,A服务 给可靠消息服务C发送一个待确认消息(包含要做的业务), C保存消息到db,并给A一个回复.
得到确认消息,A执行本地业务,完成后,给C发送一个确认或取消的消息
C收到消息后,修改消息状态,如果成功,发送消息给mq;如果失败,也是修改状态.这在一个事务中.如果这一步失败,回滚,定时任务扫描db表
B系统监听消息,消费消息,执行本地事务,给mq返回一个mq,再调用B,修改消息状态为已完成.

# 阿里巴巴分布式事务框架:Seata (seata.io)
 对两级阶段的优化.
 一阶段:通过本地事务,把业务数据和日志信息直接提交,释放锁资源和连接.和mysql事务很相似,快照和undo log
     如何避免脏写:事务中,先获取本地锁,再获取全局锁,事务提交的时候释放本地锁,扔持有全局锁.另外的事务无法获取全局锁
 二阶段:提交异步化,或者通过一阶段的日志信息进行回滚.

#





