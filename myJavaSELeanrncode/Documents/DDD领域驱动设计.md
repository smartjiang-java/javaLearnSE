                                            DDD领域驱动设计(Domain Driver Design)

## 一：背景
2004年，Eric Evans(美国的埃文斯)的一本书：领域驱动设计：软件核心复杂应对之道
领域相对于系统而言，系统是一种解决方案，领域是系统解决问题所需要的空间。这个空间主要有业务知识和活动组成。

## 为什么微服务需要DDD?
涉及到微服务解决了那些问题？解决不了那些问题？
 
从扩展和拆分，一个立方体，x轴和z轴有效的提供应用的吞吐量和可用性，然而没有解决日益增长的开发问题和应用复杂性。需要扩展y轴，即功能分解。
akf
x轴：水平复制，无差异化的，做负载均衡
z轴：有差异的拆分，按业务区分，数据切分，应用做集群
y轴：功能分解，模块化，微服务只是模块化的一种形式

微服务的特点：
1：小而专注功能内聚：按业务边界确定服务的边界
2：自治型：为了避免多个服务部署在一起，服务间要通过一种远程的网络通讯协议来沟通吗，不能通过本地；有自己的数据库
好处：
1：技术的异构性：不同的服务采用不同的技术，比如搜索服务可以用go语言
2：弹性：服务不可用，别的服务做一下垄断，做一下降级，还是可以满足主要功能的
3：扩展：扩展时节省资源和时间
4：简化部署：更快的对特定代码进行部署
5：可组合性
6：可替代性

为什么要小而专注功能内聚？
散弹式修改，子弹打出来很散，分散到系统上，需求很散，要改动的地方很多，俗称：改不动
主要原因：设计的时候没有做到单一原则，影响一个模块的变化只有一个

DDD的目的：正确定义业务边界，确定每个部分的职责和类型以及他们之间的相互关系


## 功能的分和治
问题空间和解决方案空间
技术人员着力与给出解决问题的方案，而不是探索问题的标志（为什么）
我们要先探索问题空间，最直接的就是建立模型，领域模型体现的是现实问题，然后再去做设计模型（强调的是非功能需求，为什么要这样做，是为了提高性能还是）

对软件复杂度的控制
本质复杂度：无法避免，与业务有关
偶然复杂度：选择解决问题的工具和技术有关

为什么DDD可以？
把关注点放在核心域和核心域的领域设计上
基于建模进行领域设计
通过技术专家和领域专家共同协作迭代的探索模型
将代码实现和业务紧密的连接在一起：拥抱本质复杂度，降低偶然复杂度

## DDD和微服务编码实现
从系统架构层次来看：分成很多服务，各种服务，还有注册中心，消息中间件
从一个单个服务来分，首先考虑的是如何分层 一般是三层，MVC
DDD 一般有几种分层
六边形架构，又称端口/适配器架构，核心的是domain层（业务逻辑），暴漏出去的application层，业务层要厚，技术层要薄
整洁架构：

贫血领域模型和富领域模型
虽然富领域模型比较好(会把业务委托给其他层去做)，但是我们经常使用的还是贫血领域模型（破坏了封装）
富领域对象需要： 足够大的内存     并发访问不多
这在单机软件里很多场景是可行的，但在企业应用软件里，尤其是自爱互联网软件里，是不要可行的。

通过聚合在贫富间取得平衡。聚合是一组相关领域模型的集合，用来映射业务的不变性，聚合是一致性边界，选出一个作为聚合根。（把对象分堆）
聚合根作为操作的入口，另外聚合只能持有这个聚合根的id（标识），而不能持有这个聚合根对象，也不能持有这个聚合内部对象和标识
聚合根有完整的生命周期，删除聚合根，聚合内部的所有对象都需要删除
只有聚合根能从持久化系统内查询到，边界内的对象只能从聚合根导航访问
聚合根要小，之间不能丰富的引用
一个应用服务里面一般不操作多个聚合根


## 保障聚合根原则不被破坏
ArcuUnit检查
jQAssistant也提供了DDD代码检查的插件       

通过事件风暴建模                                                                                         

我      看见绿灯亮了     决定过马路      我已经过了马路
角色      读模型         决策/命令         事件

领域模型产生事件，但是不负责发布
创建聚合根，包括完整性的校验，分布式id的生成，包括主键的生成，不能new，破坏了一致性。放在构造方法里，表意性不强，主键生成不强。
复杂对象的构建一般构造一个工厂，用builder模式也可以。


## 聚合根和数据一致性
应用服务作为事务一致性边界，一个事务里不能涉及到两个聚合的修改，跨聚合的修改应该使用最终一致性。
最终一致性成本很高，但是可以提高吞吐量。强一致性使用本地事务，但是流量不应该太大。



数据开发需求
1:需求分析
2：数据建模（ER图，业务相似，但是代码很难重构）
3：建库建表（写Dao,或通过生成工具生成）
4：编写业务逻辑

领域驱动设计
1：需求分析，有规范->统一语言，领域专家和业务专家都能接受
2：领域分析：对于领域边界的划分
3：领域建模：将同统一语言画的流程图通过uml图设计完成一个类关系图
4：核心业务逻辑
5：技术细节：DB，Cache,Message

最大的差异就是在第二步，业务：流程的流转


三层架构 controller->service->dao
四层架构 controller->facade->service->dao 协同开发，更新迭代，风格不一样，会导致重复，耦合
总结：由于设计思想不一致导致的重复和耦合

所幸的是，一些秃子开发也早就注意到了这个问题，Eric Events经过长时间思考，得到一个比较优秀的解决方案->DDD领域驱动设计：软件核心复杂应对之道






DDD资料：https://qiyu2580.gitbooks.io/iddd/content/guide-to-this-book.html
学习过程：
微服务到底怎么拆分和设计才算合理，拆多小才叫合理。微服务的边界是最容易产生争议的地方。
中台建设：需要将通用的可复用的业务能力沉淀到中台业务模型，实现企业级能力复用。因此，中台首要问题是：中台领域模型的重构，落地的时候会面临微服务的服务设计和拆分
DDD：运用DDD思想实现的微服务边界确实清晰不少.
DDD与微服务和中台的结合.中台本质是业务模型,微服务是业务模型的落地,DDD是一种设计思想,可以同时指导中台业务建设和微服务设计.
铁三角关系,DDD强调领域模型和服务设计的一体性,先有领域模型然后才有微服务,而不是脱离领域模型来谈微服务设计.
其次,就是通过战略设计,建立领域模型,划分微服务边界,这步是关键.
最后,通过战术设计,从领域模模型转向微服务设计和落地.

### 基础篇
DDD核心知识体系:领域,子域,核心域,通用域,支撑与,限界上下文,实体,值对象,聚合和聚合根的概念及依赖关系.

单机->集中式->分布式
单机:客户端和数据库,两层架构,面向过程,采用c/s架构模式,整个系统围绕数据库驱动设计和开发,总是从设计数据库和字段开始
集中式:三层架构,MVC,面向对象,也有采用传统的SOA架构,容易使系统变的臃肿,可伸缩性和扩展性较差
分布式:分布式微服务架构,DDD分层架构,实现应用之间的解耦,解决单体应用扩展性和弹性伸缩能力不足的问题

DDD核心思想是通过领域驱动设计方法定义领域类型,从而确定业务和应用边界,保证业务模型和代码模型的一致性.
DDD包括战略设计和战术设计两部分.
战略设计从业务视角出发,建立业务领域模型,划分领域边界,建立通用语言的限界上下文,这个限界上下文可以作为微服务的参考边界
战术设计从技术视角出发,侧重于领域模型的技术实现,完成软件设计开发和落地,包括:聚合根,实体,值对象,领域服务,应用服务和资源库等代码逻辑的设计和实现

战略设计:建立领域模型,通过事件风暴,是一个从发散到收敛的过程

事件风暴->领域故事分析->提取领域对象->领域对象与代码模型映射->代码落地

领域:范围,领域越大,业务范围越大,将问题域逐级细分,来降低业务理解和系统实现的复杂度.
子域:领域可以进一步划分为子领域,称为子域,每个子域对应一个更小的问题或者更小的业务范围.
例子:对保险来说,可以根据业务关联度和流程边界分为承保域,收付域,再保域,理赔等子域,而承保子域又可以分投保,寿险,财险等子子域.
子域根据自身重要性和功能属性划分为三类子域:核心域,通用域和支撑域
核心域:决定公司核心竞争力的子域是核心域,它是业务成功的主要因素.
通用域:没有太多个性化的诉求,同时被多个子域使用的子域是通用域(认证,权限)
支撑域:既不包含决定产品和公司核心竞争力的功能,也不包含通用功能的子域,就是支撑域.(数据代码类的数据字典)

客户投保,业务人员记录投保信息,系统对应有投保单实体对象
缴费完成后,业务人员将投保单转为保单,系统对应有保单实体对象,保单实体与投保单实体关联
如客户需要修改保单信息,报单变为批单,系统对应有批单实体对象,批单实体对象和报单实体关联
如客户发生理赔,生成赔案,系统对应有报案实体对象,报案实体对象与保单或者批单实体关联.

减少数据库的表
实体:拥有唯一标识,标识符在历经各种状态变更后仍能保持一致.是多个属性,操作或行为的载体.实体和值对象是组成领域模型的基础单元.充血模型,DO,有唯一的id
值对象:若干属性的集合,基本不包含业务逻辑,仍属于实体属性的一部分,无主键id

将实体和值对象组合,构成聚合,再根据业务语义将多个聚合划分到同一个限界上下文中,并完成领域建模
聚合:让实体和值对象协同合作的组织就是聚合,它用来确保这些领域对象在实现共同的业务逻辑时,保证数据的一致性.
     聚合有一个聚合跟和上下文边界,这个边界根据业务单一职责和高内聚职责,而聚合之间的边界是松耦合的.
     领域层包含了多个聚合,我们必须在聚合的整个生命周期中保持事务的一致性。聚合实例通过资源库进行持久化，对聚合的查找和获取也通过资源库完成
     聚合本身发布领域事件
聚合跟:聚合内的负责人,不仅是实体,还是聚合的管理者,在聚合内部负责协调实体和值对象按照固定的业务规则完成共同的业务逻辑
      聚合之间通过聚合跟ID关联引用,外部对象是不能直接访问聚合内实体的.
一个微服务可以是一个聚合(极致要求),也可以对包含多个聚合,聚合之间的边界是微服务内天然的逻辑边界.

### 进阶篇
领域事件,DDD分层架构,几种常见的微服务架构模型和中台设计思想

1：
领域事件：表示领域中发生的事件，一个领域事件将导致进一步的业务操作。（最终一致性）
在边界之外使用最终一致性。一次事务最多只能更改一个聚合的状态，如果一此业务操作涉及多个聚合状态的改变，应采用领域事件的最终一致性。

微服务内的领域事件：发生在微服务内的聚合之间，可以使用本地事务，不一定需要引入消息中间件，服务调用以及分布式事务
微服务间的领域事件：需要引入分布式事务，采用服务调用

事件构建和发布（事件唯一标识，发生时间，事件类型和事件源）
事件数据持久化
事件总线：提供事件分发和接收。进程内模型，在微服务内聚合之间遍历订阅者列表，采取同步或异步的模式传递数据
        微服务内的订阅者，直接分发到指定订阅者；微服务外的订阅者， 将事件数据保存到事件表并异步发送到消息中间件
消息中间件：跨服务的领域事件，实现跨服务的事件订阅和发布
事件接收和处理：微服务订阅方在应用层采用监听机制，接受消息队列中的事件数据，完成事件数据的持久化后，就可以进一步的处理业务。

2：
DDD分层架构（高内聚低耦合）：每层只能与位于下方的层发生耦合，降低了层与层之间的依赖，分层使结构变得清晰，升级和维护也更加容易。
依赖倒置后的四层架构：
用户接口层：负责向用户显示信息和解释用户指令
应用层：不应该有业务规则和逻辑，很薄，微服务之间交互的通道，调用其他的微服务。还可以进行安全认证，权限控制，事务控制，发送或订阅领域事件等
领域层：实现企业核心业务逻辑，实体通过充血模型来实现与之相关的功能
基础层：贯穿所有曾，为各层提供通用的技术和基础服务，包括第三方工具，驱动，消息中间件，网关，文件，缓存以及数据库持久化等

整洁架构：又称洋葱架构，从里到外依次是领域模型，领域服务，应用服务,用户界面和基础设施

六边形架构：端口适配器架构，通过端口与外部进行交互的
         核心业务是应用程序和领域模型，通过适配器与外部资源（app,web应用和数据库资源）交换。

对比：将核心业务逻辑与外部应用，基础资源进行隔离。  核心分领域层和应用层

中台和微服务设计的关键：领域模型和微服务的合理分层设计
中台本质上是领域的子域，可以是核心域，也可能是通用域和支撑域。通常认为阿里的中台对应DDD的通用域，将通用的公共能力沉淀到中台，对外提供共享服务。
中台划分子子域，在子域到合适大小，通过事件风暴划分限界上下文以后，就可以定义微服务了。
中台建设要聚焦领域模型

### 实战篇
事件风暴：是一个团体活动，领域专家与项目团队通过头脑风暴的形式，罗列出领域中所有的领域事件，整合之后形成最终的领域事件集合。然后对每一个事件，标注
        出导致该事件的命令，再为每一个事件标注出命令发起方的角色。命令可以是用户发起，也可以是第三方系统调用或者定时器触发等，最后对事件进行分类、
        整理出实体、聚合、聚合根以及限界上下文。
事件风暴正是DDD战略设计中经常使用的一种方法，它可以快速分析和分解复杂的业务领域，完成领域建模。

如何用事件风暴构建领域模型？
1：产品愿景：对产品顶层价值的设计，使产品目标用户、核心价值、差异化竞争点等信息达成一致，避免产品偏离方向。
2：业务场景分析：从用户视角出发，根据业务流程或用户旅程，
3：领域建模
4：服务拆分












