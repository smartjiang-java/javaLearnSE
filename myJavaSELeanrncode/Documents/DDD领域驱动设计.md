                                            DDD领域驱动设计(Domain Driver Design)

## 一：背景
2004年，Eric Evans(美国的埃文斯)的一本书：领域驱动设计：软件核心复杂应对之道
领域相对于系统而言，系统是一种解决方案，领域是系统解决问题所需要的空间。这个空间主要有业务知识和活动组成。

## 为什么微服务需要DDD?
涉及到微服务解决了那些问题？解决不了那些问题？
 
从扩展和拆分，一个立方体，x轴和z轴有效的提供应用的吞吐量和可用性，然而没有解决日益增长的开发问题和应用复杂性。需要扩展y轴，即功能分解。
akf
x轴：水平复制，无差异化的，做负载均衡
z轴：有差异的拆分，按业务区分，数据切分，应用做集群
y轴：功能分解，模块化，微服务只是模块化的一种形式

微服务的特点：
1：小而专注功能内聚：按业务边界确定服务的边界
2：自治型：为了避免多个服务部署在一起，服务间要通过一种远程的网络通讯协议来沟通吗，不能通过本地；有自己的数据库
好处：
1：技术的异构性：不同的服务采用不同的技术，比如搜索服务可以用go语言
2：弹性：服务不可用，别的服务做一下垄断，做一下降级，还是可以满足主要功能的
3：扩展：扩展时节省资源和时间
4：简化部署：更快的对特定代码进行部署
5：可组合性
6：可替代性

为什么要小而专注功能内聚？
散弹式修改，子弹打出来很散，分散到系统上，需求很散，要改动的地方很多，俗称：改不动
主要原因：设计的时候没有做到单一原则，影响一个模块的变化只有一个

DDD的目的：正确定义业务边界，确定每个部分的职责和类型以及他们之间的相互关系


## 功能的分和治
问题空间和解决方案空间
技术人员着力与给出解决问题的方案，而不是探索问题的标志（为什么）
我们要先探索问题空间，最直接的就是建立模型，领域模型体现的是现实问题，然后再去做设计模型（强调的是非功能需求，为什么要这样做，是为了提高性能还是）

对软件复杂度的控制
本质复杂度：无法避免，与业务有关
偶然复杂度：选择解决问题的工具和技术有关

为什么DDD可以？
把关注点放在核心域和核心域的领域设计上
基于建模进行领域设计
通过技术专家和领域专家共同协作迭代的探索模型
将代码实现和业务紧密的连接在一起：拥抱本质复杂度，降低偶然复杂度

## DDD和微服务编码实现
从系统架构层次来看：分成很多服务，各种服务，还有注册中心，消息中间件
从一个单个服务来分，首先考虑的是如何分层 一般是三层，MVC
DDD 一般有几种分层
六边形架构，又称端口/适配器架构，核心的是domain层（业务逻辑），暴漏出去的application层，业务层要厚，技术层要薄
整洁架构：

贫血领域模型和富领域模型
虽然富领域模型比较好(会把业务委托给其他层去做)，但是我们经常使用的还是贫血领域模型（破坏了封装）
富领域对象需要： 足够大的内存     并发访问不多
这在单机软件里很多场景是可行的，但在企业应用软件里，尤其是自爱互联网软件里，是不要可行的。

通过聚合在贫富间取得平衡。聚合是一组相关领域模型的集合，用来映射业务的不变性，聚合是一致性边界，选出一个作为聚合根。（把对象分堆）
聚合根作为操作的入口，另外聚合只能持有这个聚合根的id（标识），而不能持有这个聚合根对象，也不能持有这个聚合内部对象和标识
聚合根有完整的生命周期，删除聚合根，聚合内部的所有对象都需要删除
只有聚合根能从持久化系统内查询到，边界内的对象只能从聚合根导航访问
聚合根要小，之间不能丰富的引用
一个应用服务里面一般不操作多个聚合根


## 保障聚合根原则不被破坏
ArcuUnit检查
jQAssistant也提供了DDD代码检查的插件       

通过事件风暴建模                                                                                         

我      看见绿灯亮了     决定过马路      我已经过了马路
角色      读模型         决策/命令         事件

领域模型产生事件，但是不负责发布
创建聚合根，包括完整性的校验，分布式id的生成，包括主键的生成，不能new，破坏了一致性。放在构造方法里，表意性不强，主键生成不强。
复杂对象的构建一般构造一个工厂，用builder模式也可以。


## 聚合根和数据一致性
应用服务作为事务一致性边界，一个事务里不能涉及到两个聚合的修改，跨聚合的修改应该使用最终一致性。
最终一致性成本很高，但是可以提高吞吐量。强一致性使用本地事务，但是流量不应该太大。



数据开发需求
1:需求分析
2：数据建模（ER图，业务相似，但是代码很难重构）
3：建库建表（写Dao,或通过生成工具生成）
4：编写业务逻辑

领域驱动设计
1：需求分析，有规范->统一语言，领域专家和业务专家都能接受
2：领域分析：对于领域边界的划分
3：领域建模：将同统一语言画的流程图通过uml图设计完成一个类关系图
4：核心业务逻辑
5：技术细节：DB，Cache,Message

最大的差异就是在第二步，业务：流程的流转


三层架构 controller->service->dao
四层架构 controller->facade->service->dao 协同开发，更新迭代，风格不一样，会导致重复，耦合
总结：由于设计思想不一致导致的重复和耦合

所幸的是，一些秃子开发也早就注意到了这个问题，Eric Events经过长时间思考，得到一个比较优秀的解决方案->DDD领域驱动设计：软件核心复杂应对之道






DDD资料：https://qiyu2580.gitbooks.io/iddd/content/guide-to-this-book.html
学习过程：

## DDD 总览
DDD的通用语言，通用语言作用域某个限界上下文，它对于领域建模是非常重要的。
请记住，不管是在战术上还是战略上设计软件模型，你都应该保证：在一个特定的限界上下文中只使用一套通用语言，并且保证它的清晰性和简洁性。












