                                            DDD领域驱动设计(Domain Driver Design)

## 一：背景
2004年，Eric Evans(美国的埃文斯)的一本书：领域驱动设计：软件核心复杂应对之道
领域相对于系统而言，系统是一种解决方案，领域是系统解决问题所需要的空间。这个空间主要有业务知识和活动组成。

## 为什么微服务需要DDD?
涉及到微服务解决了那些问题？解决不了那些问题？
 
从扩展和拆分，一个立方体，x轴和z轴有效的提供应用的吞吐量和可用性，然而没有解决日益增长的开发问题和应用复杂性。需要扩展y轴，即功能分解。
akf
x轴：水平复制，无差异化的，做负载均衡
z轴：有差异的拆分，按业务区分，数据切分，应用做集群
y轴：功能分解，模块化，微服务只是模块化的一种形式

微服务的特点：
1：小而专注功能内聚：按业务边界确定服务的边界
2：自治型：为了避免多个服务部署在一起，服务间要通过一种远程的网络通讯协议来沟通吗，不能通过本地；有自己的数据库
好处：
1：技术的异构性：不同的服务采用不同的技术，比如搜索服务可以用go语言
2：弹性：服务不可用，别的服务做一下垄断，做一下降级，还是可以满足主要功能的
3：扩展：扩展时节省资源和时间
4：简化部署：更快的对特定代码进行部署
5：可组合性
6：可替代性

为什么要小而专注功能内聚？
散弹式修改，子弹打出来很散，分散到系统上，需求很散，要改动的地方很多，俗称：改不动
主要原因：设计的时候没有做到单一原则，影响一个模块的变化只有一个

DDD的目的：正确定义业务边界，确定每个部分的职责和类型以及他们之间的相互关系


## 功能的分和治
问题空间和解决方案空间
技术人员着力与给出解决问题的方案，而不是探索问题的标志（为什么）
我们要先探索问题空间，最直接的就是建立模型，领域模型体现的是现实问题，然后再去做设计模型（强调的是非功能需求，为什么要这样做，是为了提高性能还是）

对软件复杂度的控制
本质复杂度：无法避免，与业务有关
偶然复杂度：选择解决问题的工具和技术有关

为什么DDD可以？
把关注点放在核心域和核心域的领域设计上
基于建模进行领域设计
通过技术专家和领域专家共同协作迭代的探索模型
将代码实现和业务紧密的连接在一起：拥抱本质复杂度，降低偶然复杂度

## DDD和微服务编码实现
从系统架构层次来看：分成很多服务，各种服务，还有注册中心，消息中间件
从一个单个服务来分，首先考虑的是如何分层 一般是三层，MVC
DDD 一般有几种分层
六边形架构，又称端口/适配器架构，核心的是domain层（业务逻辑），暴漏出去的application层，业务层要厚，技术层要薄
整洁架构：

贫血领域模型和富领域模型
虽然富领域模型比较好(会把业务委托给其他层去做)，但是我们经常使用的还是贫血领域模型（破坏了封装）
富领域对象需要： 足够大的内存     并发访问不多
这在单机软件里很多场景是可行的，但在企业应用软件里，尤其是自爱互联网软件里，是不要可行的。

通过聚合在贫富间取得平衡。聚合是一组相关领域模型的集合，用来映射业务的不变性，聚合是一致性边界，选出一个作为聚合根。（把对象分堆）
聚合根作为操作的入口，另外聚合只能持有这个聚合根的id（标识），而不能持有这个聚合根对象，也不能持有这个聚合内部对象和标识
聚合根有完整的生命周期，删除聚合根，聚合内部的所有对象都需要删除
只有聚合根能从持久化系统内查询到，边界内的对象只能从聚合根导航访问
聚合根要小，之间不能丰富的引用


## 保障聚合根原则不被破坏
ArcuUnit检查
jQAssistant也提供了DDD代码检查的插件

通过事件风暴建模

我      看见绿灯亮了     决定过马路      我已经过了马路
角色      读模型         决策/命令         事件

























